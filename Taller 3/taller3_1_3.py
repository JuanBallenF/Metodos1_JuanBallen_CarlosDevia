# -*- coding: utf-8 -*-
"""taller3_1.3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1an7DnDCd4orfzdTs3rxQ8iQ-Ff45wBHP
"""

import numpy as np

def fun(x):
  f = 3*x**5 + 5*x**4 - x**3
  return f

def dfun(x):
  df = 15*x**4 + 20*x**3 - 3*x**2
  if df == 0:
    exit()
  return df

a = -2
b = -1.0
fun_a = fun(a)
fun_b = fun(b)

err_tol = 1.0
err_rel = 1000
Bolzano = (a+b)/2.0
k = 1
raicc=[]




while(err_rel > err_tol):

       fsol = fun(Bolzano)

       if np.sign(fun_a) != np.sign(fsol):
          b = Bolzano
       else:   
          a = Bolzano

       fun_a = fsol

       x_m = Bolzano

       Bolzano2 = (a+b)/2.0

       k = k+1

       err_rel = abs((Bolzano - x_a) / Bolzano) * 100
    

if -1.5 <= Bolzano and -1000 <= Bolzano:
 x_a = Bolzano
elif 0.5 < Bolzano and 1000 < Bolzano:
  x_a = Bolzano 
elif -1.4 < Bolzano and 0.4 < Bolzano:
   x_a = Bolzano

tol = 0.0000001
err_rel = 100
x_a = Bolzano

fx_a = fun(x_a)
df_a = dfun(x_a)
sol = x_a - fx_a/ df_n

while(err_rel >= tol):
      x_a = sol
      fx_a = fun(x_a)
      df_a = dfun(x_a)
      sol = x_a - fx_a/ df_a
      err_rel = abs((sol - x_a)/sol)*100

print("raiz 1:",sol)
raicc.append(sol)
#raicc

c = 0.1
d = 0.5
fun_c = fun(c)
fun_d = fun(d)

err_tol = 1.0
err_rel = 1000
Bolzano = (c+d)/2.0
k = 1

while(err_rel > err_tol):

       fsol = fun(Bolzano)

       if np.sign(fun_c) != np.sign(fsol):
          d = Bolzano
       else:   
          c = Bolzano

       fun_c = fsol

       x_p = Bolzano

       Bolzano2 = (c+d)/2.0

       k = k+1

       err_rel = abs((Bolzano - x_p) / Bolzano) * 100
    



if -1.5 < Bolzano and -1000 < Bolzano:
 x_p = Bolzano
elif 0.5 < Bolzano and 1000 < Bolzano:
  x_p = Bolzano 
elif -1.4 < Bolzano and 0.4 < Bolzano:
   x_p = Bolzano
   
tol = 0.0000001
err_rel = 100


fx_p = fun(x_p)
df_p = dfun(x_p)
sol = x_p - fx_p/ df_p

while(err_rel >= tol):
      x_p = sol
      fx_p = fun(x_p)
      df_p = dfun(x_p)
      sol = x_p - fx_p/ df_p
      err_rel = abs((sol - x_p)/sol)*100

print("raiz 2:",sol)
raicc.append(sol)
#raicc

e = -0.008
f = 0.005
fun_e = fun(e)
fun_f = fun(f)

err_tol = 1.0
err_rel = 1000
Bolzano = (e+f)/2.0
k = 1


while(err_rel > err_tol):

       fsol = fun(Bolzano)

       if np.sign(fun_e) != np.sign(fsol):
          f = Bolzano
       else:   
          e = Bolzano

       fun_e = fsol

       x_m = Bolzano

       Bolzano2 = (e+f)/2.0

       k = k+1

       err_rel = abs((Bolzano - x_m) / Bolzano) * 100

if -1.5 < Bolzano and -1000 < Bolzano:
 x_m = Bolzano
elif 0.5 < Bolzano and 1000 < Bolzano:
  x_m = Bolzano 
elif -1.4 < Bolzano and 0.4 < Bolzano:
   x_m = Bolzano

tol = 0.00001
err_rel = 100


fx_m = fun(x_m)
df_m = dfun(x_m)
sol = x_m - fx_m/ df_m

while(err_rel >= tol):
      x_m = sol
      fx_m = fun(x_m)
      df_m = dfun(x_m)
      sol = x_m - fx_m/ df_m
      err_rel = abs((sol - x_m)/sol)*100


print("raiz 3:",sol)
raicc.append(sol)

print ("Todas las ra√≠ces:",raicc)

